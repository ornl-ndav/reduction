/**
 * $Id$
 *
 * \file array_manip/test/src/add_ncerr_test.cpp
 */

#include "arith.hpp"
#include "test_common.hpp"
#include <iostream>

using namespace std;

const int NUM_VAL = 5;

/**
 * \ingroup add_ncerr_test
 *
 * This function compare the output data calculated by the
 * library function add_ncerr with the true output data manually calculated.
 * Any discrepancy between the outputs will generate an error message
 * that gives details about the location and type ofq the error.
 *
 * This function test the addition of a scalar with each
 * element, \f$i\f$, of an array according to the equation
 * \f[
 * true_output_vs[i]=input1[i]+a
 * \f]
 * with the uncertainties given by
 * \f[
 * (true_output_vs_err2[i])^2=(\sigma_a)^2+(input2_err2[i])^2
 * \f]
 *
 * and the case of the addition of each element, \f$i\f$, of two arrays
 * according to the equation
 * \f[
 * true_output_vv[i]=input1[i]+input2[i]
 * \f]
 * with the uncertainties given by
 * \f[
 * (true_output_vv_err2[i])^2=(input1_err2[i])^2+(input2_err2[i])^2
 * \f]
 *
 * where
 * \f$true_output_vs[i]\f$ is the \f$i^{th}\f$ component of the true output
 * array for the vector-scalar case, \f$true_output_vv[i]\f$ is the
 * \f$i^{th}\f$ component of
 * the true output array for the vector-vector case,
 * \f$input1[i]\f$ is the \f$i^{th}\f$ component of the first array being
 * added, \f$input2[i]\f$ is the \f$i^{th}\f$ component of the second
 * array being added, \f$a=input2[4]\f$, \f$\sigma_a=input2_err2[4]\f$,
 *\f$output_vs_err2[i]\f$ is the \f$i^{th}\f$ component
 * of the uncertainty of the output array for the vector-scalar case,
 * \f$output_vv_err2[i]\f$ is the \f$i^{th}\f$ component of the
 * uncertainty of the output array for the vector-vector case,
 * \f$input1_err2[i]\f$ is the \f$i^{th}\f$ component of the uncertainty
 * in the first array, and \f$input2_err2[i]\f$ is the \f$i^{th}\f$ component
 * of the uncertainty in the second array.
 *
 * The \f$true_output_vs[i]\f$ and \f$true_output_vv[i]\f$ are compared
 * with the output produced by the add_ncerr function (\f$output_vs[i]\f$
 * and \f$output_vv[i]\f$).
 *
 * Notation used:
 * vv : vector-vector
 * vs : vector-scalar
 * VV = "v,v"
 * SV = "s,v"
 * VS = "v,s"
 * ERROR = "error "
 * EMPTY = ""
 */

 /**
 * Function that initialize the arrays input1 and input2
 */
template <typename NumT>
void initialize_inputs(Nessi::Vector<NumT> & input1,
                       Nessi::Vector<NumT> & input1_err2,
                       Nessi::Vector<NumT> & input2,
                       Nessi::Vector<NumT> & input2_err2)
{
  for( int i=0 ; i<NUM_VAL ; i++ )
    {
    input1.push_back(static_cast<NumT>(NUM_VAL+1-i)); // 6,5,4,3,2
      input2.push_back(static_cast<NumT>(i));           // 0,1,2,3,4
      input1_err2.push_back(static_cast<NumT>(1.));
      input2_err2.push_back(static_cast<NumT>(1.));
    }
}

 /**
 * Function that generate the true output using input1 and input2
 */
template <typename NumT>
void initialize_true_outputs(Nessi::Vector<NumT> & output_vs,
                             Nessi::Vector<NumT> & output_vs_err2,
                             Nessi::Vector<NumT> & output_vv,
                             Nessi::Vector<NumT> & output_vv_err2)
{
  // initialize the correct outputs for vector vector case
  output_vv.push_back(static_cast<NumT>(6.)); // =0+6
  output_vv_err2.push_back(static_cast<NumT>(2.));
  output_vv.push_back(static_cast<NumT>(6.)); // =1+5
  output_vv_err2.push_back(static_cast<NumT>(2.));
  output_vv.push_back(static_cast<NumT>(6.)); // =2+4
  output_vv_err2.push_back(static_cast<NumT>(2.));
  output_vv.push_back(static_cast<NumT>(6.)); // =3+3
  output_vv_err2.push_back(static_cast<NumT>(2.));
  output_vv.push_back(static_cast<NumT>(6.)); // =4+2
  output_vv_err2.push_back(static_cast<NumT>(2.));

  // initialize the correct outputs for vector scalar case
  output_vs.push_back(static_cast<NumT>(10.)); // =4+6
  output_vs_err2.push_back(static_cast<NumT>(2.));
  output_vs.push_back(static_cast<NumT>(9.));  // =4+5
  output_vs_err2.push_back(static_cast<NumT>(2.));
  output_vs.push_back(static_cast<NumT>(8.));  // =4+4
  output_vs_err2.push_back(static_cast<NumT>(2.));
  output_vs.push_back(static_cast<NumT>(7.));  // =4+3
  output_vs_err2.push_back(static_cast<NumT>(2.));
  output_vs.push_back(static_cast<NumT>(6.));  // =4+2
  output_vs_err2.push_back(static_cast<NumT>(2.));
}

/**
 * Function that test the discrepancies between the output
 * generated by the add_ncerr function for the vs case,
 * \f$output_vs\f$ and \f$output_vs_err2\f$, and the vv case,
 * \f$output_vv\f$ and \f$output_vv_err2\f$,
 * and the true_output generated by the initialize_true_outputs function
 * for the vs case, \f$true_output_vs\f$ and \f$true_output_vs_err2\f$, and
 * for the vv case, \f$true_output_vv\f$ and \f$true_output_vv_err2\f$.
 * if there are no differences found between the two number compared,
 * test_okay return true, otherwise false is returned.
 */
 template <typename NumT>
bool test_okay(Nessi::Vector<NumT> & output_vs,
               Nessi::Vector<NumT> & output_vs_err2,
               Nessi::Vector<NumT> & true_output_vs,
               Nessi::Vector<NumT> & true_output_vs_err2,
               Nessi::Vector<NumT> & output_vv,
               Nessi::Vector<NumT> & output_vv_err2,
               Nessi::Vector<NumT> & true_output_vv,
               Nessi::Vector<NumT> & true_output_vv_err2)
{
  // vector scalar
  if(!test_okay(output_vs,true_output_vs,VS))
    return false;
  if(!test_okay(output_vs_err2,true_output_vs_err2,VS,ERROR))
    return false;

  // vector vector
  if(!test_okay(output_vv,true_output_vv,VV))
    return false;
  if(!test_okay(output_vv_err2,true_output_vv_err2,VV,ERROR))
    return false;

  // everything okay
  return true;
}

/**
 * Function that generate the data using the add_ncerr function
 * (as described in the documentation of the add_ncerr function)
 * and launch the comparison of the data
 */
template <typename NumT>
bool test_func(NumT key){ // key forces correct test to happen
  // allocate arrays
  Nessi::Vector<NumT> input1;
  Nessi::Vector<NumT> input1_err2;
  Nessi::Vector<NumT> input2;
  Nessi::Vector<NumT> input2_err2;
  Nessi::Vector<NumT> output_vs(NUM_VAL);
  Nessi::Vector<NumT> output_vs_err2(NUM_VAL);
  Nessi::Vector<NumT> output_vv(NUM_VAL);
  Nessi::Vector<NumT> output_vv_err2(NUM_VAL);
  Nessi::Vector<NumT> true_output_vs;
  Nessi::Vector<NumT> true_output_vs_err2;
  Nessi::Vector<NumT> true_output_vv;
  Nessi::Vector<NumT> true_output_vv_err2;

  // fill in values as appropriate
  initialize_inputs(input1,input1_err2,input2,input2_err2);
  initialize_true_outputs(true_output_vs,true_output_vs_err2,
                          true_output_vv,true_output_vv_err2);

  // run the code being tested
  ArrayManip::add_ncerr(input1, input1_err2, input2, input2_err2,
                        output_vv, output_vv_err2);
  ArrayManip::add_ncerr(input1, input1_err2,
                        input2[NUM_VAL-1], input2_err2[NUM_VAL-1],
                        output_vs, output_vs_err2);

  return test_okay(output_vs, output_vs_err2,
                   true_output_vs, true_output_vs_err2,
                   output_vv, output_vv_err2,
                   true_output_vv, true_output_vv_err2);
}

/**
 * Main test functino that test add_ncerr using
 * float, double, int and unsigned int
 */
int main()
{
  cout << "add_ncerr_test.cpp..........";

  if(!test_func(static_cast<float>(1)))
    return -1;

  if(!test_func(static_cast<double>(1)))
    return -1;

  if(!test_func(static_cast<int>(1)))
    return -1;

  if(!test_func(static_cast<unsigned int>(1)))
    return -1;

  cout << "Functionality OK" << endl;

  return 0;
}

