/*
 *                     SNS Common Libraries
 *           A part of the SNS Analysis Software Suite.
 *
 *                  Spallation Neutron Source
 *          Oak Ridge National Laboratory, Oak Ridge TN.
 *
 *
 *                             NOTICE
 *
 * For this software and its associated documentation, permission is granted
 * to reproduce, prepare derivative works, and distribute copies to the public
 * for any purpose and without fee.
 *
 * This material was prepared as an account of work sponsored by an agency of
 * the United States Government.  Neither the United States Government nor the
 * United States Department of Energy, nor any of their employees, makes any
 * warranty, express or implied, or assumes any legal liability or
 * responsibility for the accuracy, completeness, or usefulness of any
 * information, apparatus, product, or process disclosed, or represents that
 * its use would not infringe privately owned rights.
 *
 */

/**
 * $Id$
 *
 * \file array_manip/inc/arith.hpp
 */
#ifndef _ARITH_HPP
#define _ARITH_HPP 1

#include "nessi.hpp"
#include <string>

/**
 * \namespace ArrayManip
 *
 * \brief This sub-library contains the various simple arithematic
 * operations on arrays.
 *
 * All of these functions are written in reference to SNS
 * 107030214-TD0001-R00, "Data Reduction Library Software Requirements
 * and Specifications."
 */
namespace ArrayManip
{
  /**
   * \defgroup add_ncerr ArrayManip::add_ncerr
   * \{
   */

  /**
   * \brief This function is described in section 3.6.
   *
   * This function adds each element, \f$i\f$, of two arrays according
   * to the equation
   * \f[
   * data_o[i]=data_1[i]+data_2[i]
   * \f]
   * and the uncorrelated uncertainties will be processed according to
   * the equation
   * \f[
   * \sigma_o^2[i]=\sigma_1^2[i]+\sigma_2^2[i]
   * \f]
   * Where \f$data_o[i]\f$ is the \f$i^{th}\f$ component of the output
   * array, \f$data_1[i]\f$ is the \f$i^{th}\f$ component of the first
   * array being added, \f$data_2[i]\f$ is the \f$i^{th}\f$ component
   * of the second array being added, \f$\sigma_o[i]\f$ is the
   * \f$i^{th}\f$ component of the uncertainty of the output array,
   * \f$\sigma_1[i]\f$ is the \f$i^{th}\f$ component of the
   * uncertainty in the first array, and \f$\sigma_2[i]\f$ is the
   * \f$i^{th}\f$ component of the uncertainty in the second array.
   *
   * This function is an adaptation from the ARCS reduction software written
   * by Tim Kelley (CalTech).
   *
   * \param input1 (INPUT) is the first array to be added
   * \param input1_err2 (INPUT) is the square of the uncertainty in
   * the first array to be added
   * \param input2 (INPUT) is the second array to be added
   * \param input2_err2 (INPUT) the square of the uncertainty in the
   * second array to be added
   * \param output (OUTPUT) the result array
   * \param output_err2 (OUTPUT) the square of the uncertainty in the
   * result array
   *
   * \param temp holds temporary memory to be passed to the function
   *
   * \return A set of warnings generated by the function
   *
   * <b>Warning when using integers</b>
   * One must be aware of the overflow property when using integers.
   * The overflow occurs when trying to use negative numbers with unsigned
   * int and number outside the range with ints (signed and unsigned).
   *
   * As an  example, \f$2-4\f$ will return \f$UINT\_MAX-1\f$, where
   * \f$UINT\_MAX\f$ is the largest value that will fit in an unsigned int.
   * Because the true result of the equation is negative, which
   * is not allowed with unsigned int, the result is wrapped around 0.
   * To generalize, the result returned with unsigned int is
   * \f[
   * result_{returned} = (result_{real})\ \%\ (UINT\_MAX + 1)
   * \f]
   * where \f$result_{returned}\f$ is the result returned by the function,
   * \f$result_{real}\f$ is the real result that should be returned by the
   * function, and \f$\%\f$ is the operator modulo.
   *
   * \exception std::invalid_argument is thrown if the size of input1,
   * input1_err2, input2, input2_err2, output, and output_err2 are not
   * identical.
   */
  template <typename NumT>
  std::string
  add_ncerr(const Nessi::Vector<NumT> & input1,
            const Nessi::Vector<NumT> & input1_err2,
            const Nessi::Vector<NumT> & input2,
            const Nessi::Vector<NumT> & input2_err2,
            Nessi::Vector<NumT> & output,
            Nessi::Vector<NumT> & output_err2,
            void *temp=NULL);

  /**
   * \brief This function is described in section 3.1.
   *
   * This function adds a scalar to each element, \f$i\f$, of an array
   * according to the equation
   * \f[
   * data_o[i]=a+data_i[i]
   * \f]
   * and the uncorrelated uncertainties will be processed according to
   * the equation
   * \f[
   * \sigma_o^2[i]=\sigma_a^2+\sigma_i^2[i]
   * \f]
   * Where \f$data_o[i]\f$ is the \f$i^{th}\f$ component of the output
   * array, \f$a\f$ is the scalar being added to each element,
   * \f$data_i[i]\f$ is the \f$i^{th}\f$ component of the input array,
   * \f$\sigma_o[i]\f$ is the \f$i^{th}\f$ component of the
   * uncertainty of the output array, \f$\sigma_a\f$ is the
   * uncertainty in the scalar, and \f$\sigma_i[i]\f$ is the
   * \f$i^{th}\f$ component of the uncertainty in the input array.
   *
   * This function is an adaptation from the ARCS reduction software written
   * by Tim Kelley (CalTech).
   *
   * \param array_in (INPUT) is the array to be added
   * \param array_in_err2 (INPUT) is the square of the uncertainty in
   * the array to be added
   * \param scalar (INPUT) is the scalar to add to each element of
   * array_in
   * \param scalar_err2 (INPUT) is the square of the uncertainty in the
   * scalar
   * \param array_out (OUTPUT) is the result array
   * \param array_out_err2 (OUTPUT) is the square of the uncertainty in
   * the result array
   *
   * \param temp holds temporary memory to be passed to the function
   *
   * \return A set of warnings generated by the function
   *
   * <b>Warning when using integers</b>
   * One must be aware of the overflow property when using integers.
   * The overflow occurs when trying to use negative numbers with unsigned
   * int and number outside the range with ints (signed and unsigned).
   *
   * As an  example, \f$2-4\f$ will return \f$UINT\_MAX-1\f$, where
   * \f$UINT\_MAX\f$ is the largest value that will fit in an unsigned int.
   * Because the true result of the equation is negative, which
   * is not allowed with unsigned int, the result is wrapped around 0.
   * To generalize, the result returned with unsigned int is
   * \f[
   * result_{returned} = (result_{real})\ \%\ (UINT\_MAX + 1)
   * \f]
   * where \f$result_{returned}\f$ is the result returned by the function,
   * \f$result_{real}\f$ is the real result that should be returned by the
   * function, and \f$\%\f$ is the operator modulo.
   *
   * \exception std::invalid_argument is thrown if the size of
   * array_in, array_in_err2, array_out, and array_out_err2 are not
   * identical.
   */
  template <typename NumT>
  std::string
  add_ncerr(const Nessi::Vector<NumT> & array_in,
            const Nessi::Vector<NumT> & array_in_err2,
            const NumT scalar,
            const NumT scalar_err2,
            Nessi::Vector<NumT> & array_out,
            Nessi::Vector<NumT> & array_out_err2,
            void *temp=NULL);

  /**
   * \}
   */ // end of add_ncerr group

  /**
   * \defgroup div_ncerr ArrayManip::div_ncerr
   * \{
   */

  /**
   * \brief This function is described in section 3.9.
   *
   * This function divides each element, \f$i\f$, of two arrays
   * according to the equation
   * \f[
   * data_o[i]=data_1[i]/data_2[i]
   * \f]
   * and the uncorrelated uncertainties will be processed according to
   * the equation
   * \f[
   * \sigma_o^2[i]=\left(\frac{data_1[i]\times \sigma_2[i]}{data_2^2[i]}
   * \right)^2+\left(\frac{\sigma_1[i]}{data_2[i]}\right)^2
   * \f]
   * Where \f$data_o[i]\f$ is the \f$i^{th}\f$ component of the output
   * array, \f$data_1[i]\f$ is the \f$i^{th}\f$ component of the array
   * being divided, \f$data_2[i]\f$ is the \f$i^{th}\f$ component of
   * the dividing array, \f$\sigma_o[i]\f$ is the \f$i^{th}\f$
   * component of the uncertainty of the output array,
   * \f$\sigma_1[i]\f$ is the \f$i^{th}\f$ component of the
   * uncertainty in the array being divided, and \f$\sigma_i[i]\f$ is
   * the \f$i^{th}\f$ component of the uncertainty in the dividing
   * array.
   *
   * This function is an adaptation from the ARCS reduction software written
   * by Tim Kelley (CalTech).
   *
   * \param input1 (INPUT) is the array to be divided from
   * \param input1_err2 (INPUT) is the square of the uncertainty in
   * the array to be divided from
   * \param input2 (INPUT) is the array to divide by
   * \param input2_err2 (INPUT) the square of the uncertainty in the
   * array to divide by
   * \param output (OUTPUT) the result array
   * \param output_err2 (OUTPUT) the square of the uncertainty in the
   * result array
   *
   * \param temp holds temporary memory to be passed to the function
   *
   * \return A set of warnings generated by the function
   *
   * <b>Warning when using integers</b>
   * One must be aware of the overflow property when using integers.
   * The overflow occurs when trying to use negative numbers with unsigned
   * int and number outside the range with ints (signed and unsigned).
   *
   * As an  example, \f$2-4\f$ will return \f$UINT\_MAX-1\f$, where
   * \f$UINT\_MAX\f$ is the largest value that will fit in an unsigned int.
   * Because the true result of the equation is negative, which
   * is not allowed with unsigned int, the result is wrapped around 0.
   * To generalize, the result returned with unsigned int is
   * \f[
   * result_{returned} = (result_{real})\ \%\ (UINT\_MAX + 1)
   * \f]
   * where \f$result_{returned}\f$ is the result returned by the function,
   * \f$result_{real}\f$ is the real result that should be returned by the
   * function, and \f$\%\f$ is the operator modulo.
   *
   * \exception std::invalid_argument is thrown if the size of input1,
   * input1_err2, input2, input2_err2, output, and output_err2 are not
   * identical.
   */
  template <typename NumT>
  std::string
  div_ncerr(const Nessi::Vector<NumT> & input1,
            const Nessi::Vector<NumT> & input1_err2,
            const Nessi::Vector<NumT> & input2,
            const Nessi::Vector<NumT> & input2_err2,
            Nessi::Vector<NumT> & output,
            Nessi::Vector<NumT> & output_err2,
            void *temp=NULL);

  /**
   * \brief This function is described in section 3.4.
   *
   * This function divides a scalar by each element, \f$i\f$, of an
   * array according to the equation
   * \f[
   * data_o[i]=a/data_i[i]
   * \f]
   * and the uncorrelated uncertainties will be processed according to
   * the equation
   * \f[
   * \sigma_o^2[i]=\left(\frac{a \times \sigma_i[i]}{data_i^2[i]}\right)^2
   *                 +\left(\frac{\sigma_a}{data_i[i]}\right)^2
   * \f]
   * Where \f$data_o[i]\f$ is the \f$i^{th}\f$ component of the output
   * array, \f$a\f$ is the scalar each element is dividing,
   * \f$data_i[i]\f$ is the \f$i^{th}\f$ component of the input array,
   * \f$\sigma_o[i]\f$ is the \f$i^{th}\f$ component of the
   * uncertainty of the output array, \f$\sigma_a\f$ is the
   * uncertainty in the scalar, and \f$\sigma_i[i]\f$ is the
   * \f$i^{th}\f$ component of the uncertainty in the input array.
   *
   * This function is an adaptation from the ARCS reduction software written
   * by Tim Kelley (CalTech).
   *
   * \param scalar (INPUT) is the scalar to be divided by each element
   * of array_in
   * \param scalar_err2 (INPUT) is the square of the uncertainty in the
   * scalar
   * \param array_in (INPUT) is the array to divide from the scalar
   * \param array_in_err2 (INPUT) is the square of the uncertainty in the
   * array to divide the scalar
   * \param array_out (OUTPUT) is the result array
   * \param array_out_err2 (OUTPUT) is the square of the uncertainty in
   * the result array
   *
   * \param temp holds temporary memory to be passed to the function
   *
   * \return A set of warnings generated by the function
   *
   * <b>Warning when using integers</b>
   * One must be aware of the overflow property when using integers.
   * The overflow occurs when trying to use negative numbers with unsigned
   * int and number outside the range with ints (signed and unsigned).
   *
   * As an  example, \f$2-4\f$ will return \f$UINT\_MAX-1\f$, where
   * \f$UINT\_MAX\f$ is the largest value that will fit in an unsigned int.
   * Because the true result of the equation is negative, which
   * is not allowed with unsigned int, the result is wrapped around 0.
   * To generalize, the result returned with unsigned int is
   * \f[
   * result_{returned} = (result_{real})\ \%\ (UINT\_MAX + 1)
   * \f]
   * where \f$result_{returned}\f$ is the result returned by the function,
   * \f$result_{real}\f$ is the real result that should be returned by the
   * function, and \f$\%\f$ is the operator modulo.
   *
   * \exception std::invalid_argument is thrown if the size of
   * array_in, array_in_err2, array_out, and array_out_err2 are not
   * identical.
   */
  template <typename NumT>
  std::string
  div_ncerr(const NumT scalar,
            const NumT scalar_err2,
            const Nessi::Vector<NumT> & array_in,
            const Nessi::Vector<NumT> & array_in_err2,
            Nessi::Vector<NumT> & array_out,
            Nessi::Vector<NumT> & array_out_err2,
            void *temp=NULL);

  /**
   * \brief This function is described in section 3.5.
   *
   * This function divides each element, \f$i\f$, of an array by a
   * scalar according to the equation
   * \f[
   * data_o[i]=data_i[i]/a
   * \f]
   * and the uncorrelated uncertainties will be processed according to
   * the equation
   * \f[
   * \sigma_o^2[i]=\left(\frac{\sigma_i[i]}{a}\right)^2
   *                 +\left(\frac{data_i[i]\times\sigma_a}{a^2}\right)^2
   * \f]
   * Where \f$data_o[i]\f$ is the \f$i^{th}\f$ component of the output
   * array, \f$a\f$ is the scalar dividing each element,
   * \f$data_i[i]\f$ is the \f$i^{th}\f$ component of the input array,
   * \f$\sigma_o[i]\f$ is the \f$i^{th}\f$ component of the
   * uncertainty of the output array, \f$\sigma_a\f$ is the
   * uncertainty in the scalar, and \f$\sigma_i[i]\f$ is the
   * \f$i^{th}\f$ component of the uncertainty in the input array.
   *
   * This function is an adaptation from the ARCS reduction software written
   * by Tim Kelley (CalTech).
   *
   * \param array_in (INPUT) is the array to be divided by the scalar
   * \param array_in_err2 (INPUT) is the square of the uncertainty in the
   * array to be divided by the scalar
   * \param scalar (INPUT) is the scalar to divide each element of
   * array_in by
   * \param scalar_err2 (INPUT) is the square of the uncertainty in the
   * scalar
   * \param array_out (OUTPUT) is the result array
   * \param array_out_err2 (OUTPUT) is the square of the uncertainty in
   * the result array
   *
   * \param temp holds temporary memory to be passed to the function
   *
   * \return A set of warnings generated by the function
   *
   * <b>Warning when using integers</b>
   * One must be aware of the overflow property when using integers.
   * The overflow occurs when trying to use negative numbers with unsigned
   * int and number outside the range with ints (signed and unsigned).
   *
   * As an  example, \f$2-4\f$ will return \f$UINT\_MAX-1\f$, where
   * \f$UINT\_MAX\f$ is the largest value that will fit in an unsigned int.
   * Because the true result of the equation is negative, which
   * is not allowed with unsigned int, the result is wrapped around 0.
   * To generalize, the result returned with unsigned int is
   * \f[
   * result_{returned} = (result_{real})\ \%\ (UINT\_MAX + 1)
   * \f]
   * where \f$result_{returned}\f$ is the result returned by the function,
   * \f$result_{real}\f$ is the real result that should be returned by the
   * function, and \f$\%\f$ is the operator modulo.
   *
   * \exception std::invalid_argument is thrown if the size of
   * array_in, array_in_err2, array_out, and array_out_err2 are not
   * identical.
   */
  template <typename NumT>
  std::string
  div_ncerr(const Nessi::Vector<NumT> & array_in,
            const Nessi::Vector<NumT> & array_in_err2,
            const NumT scalar,
            const NumT scalar_err2,
            Nessi::Vector<NumT> & array_out,
            Nessi::Vector<NumT> & array_out_err2,
            void *temp=NULL);

  /**
   * \}
   */ // end of div_ncerr group

  /**
   * \defgroup mult_ncerr ArrayManip::mult_ncerr
   * \{
   */

  /**
   * \brief This function is described in section 3.8.
   *
   * This function multiplies each element, \f$i\f$, of two arrays
   * according to the equation
   * \f[
   * data_o[i]=data_1[i]\times data_2[i]
   * \f]
   * and the uncorrelated uncertainties will be processed according to
   * the equation
   * \f[
   * \sigma_o^2[i]=(data_1[i]\times\sigma_2[i])^2
   * +(data_2[i]\times\sigma_1[i])^2
   * \f]
   * Where \f$data_o[i]\f$ is the \f$i^{th}\f$ component of the output
   * array, \f$data_1[i]\f$ is the \f$i^{th}\f$ component of the first
   * array, \f$data_2[i]\f$ is the \f$i^{th}\f$ component of the
   * second array, \f$\sigma_o[i]\f$ is the \f$i^{th}\f$ component of
   * the uncertainty of the output array, \f$\sigma_1[i]\f$ is the
   * \f$i^{th}\f$ component of the uncertainty in the first array, and
   * \f$\sigma_2[i]\f$ is the \f$i^{th}\f$ component of the
   * uncertainty in the second array.
   *
   * This function is an adaptation from the ARCS reduction software written
   * by Tim Kelley (CalTech).
   *
   * \param input1 (INPUT) is the first array to be multiplied
   * \param input1_err2 (INPUT) is the square of the uncertainty in
   * the first array to be multiplied
   * \param input2 (INPUT) is the second array to be multiplied
   * \param input2_err2 (INPUT) the square of the uncertainty in the
   * second array to be multiplied
   * \param output (OUTPUT) the result array
   * \param output_err2 (OUTPUT) the square of the uncertainty in the
   * result array
   *
   * \param temp holds temporary memory to be passed to the function
   *
   * \return A set of warnings generated by the function
   *
   * <b>Warning when using integers</b>
   * One must be aware of the overflow property when using integers.
   * The overflow occurs when trying to use negative numbers with unsigned
   * int and number outside the range with ints (signed and unsigned).
   *
   * As an  example, \f$2-4\f$ will return \f$UINT\_MAX-1\f$, where
   * \f$UINT\_MAX\f$ is the largest value that will fit in an unsigned int.
   * Because the true result of the equation is negative, which
   * is not allowed with unsigned int, the result is wrapped around 0.
   * To generalize, the result returned with unsigned int is
   * \f[
   * result_{returned} = (result_{real})\ \%\ (UINT\_MAX + 1)
   * \f]
   * where \f$result_{returned}\f$ is the result returned by the function,
   * \f$result_{real}\f$ is the real result that should be returned by the
   * function, and \f$\%\f$ is the operator modulo.
   *
   * \exception std::invalid_argument is thrown if the size of input1,
   * input1_err2, input2, input2_err2, output, and output_err2 are not
   * identical.
   */
  template <typename NumT>
  std::string
  mult_ncerr(const Nessi::Vector<NumT> & input1,
             const Nessi::Vector<NumT> & input1_err2,
             const Nessi::Vector<NumT> & input2,
             const Nessi::Vector<NumT> & input2_err2,
             Nessi::Vector<NumT> & output,
             Nessi::Vector<NumT> & output_err2,
             void *temp=NULL);

  /**
   * \brief This function is described in section 3.3.
   *
   * This function multiplies a scalar to each element, \f$i\f$, of an
   * array according to the equation
   * \f[
   * data_o[i]=data_i[i]\times a
   * \f]
   * and the uncorrelated uncertainties will be processed according to
   * the equation
   * \f[
   * \sigma_o^2[i]=(a\times\sigma_i[i])^2+(data_i[i]\times\sigma_a)^2
   * \f]
   * Where \f$data_o[i]\f$ is the \f$i^{th}\f$ component of the output
   * array, \f$a\f$ is the scalar being multiplied to each element,
   * \f$data_i[i]\f$ is the \f$i^{th}\f$ component of the input array,
   * \f$\sigma_o[i]\f$ is the \f$i^{th}\f$ component of the
   * uncertainty of the output array, \f$\sigma_a\f$ is the
   * uncertainty in the scalar, and \f$\sigma_i[i]\f$ is the
   * \f$i^{th}\f$ component of the uncertainty in the input array.
   *
   * This function is an adaptation from the ARCS reduction software written
   * by Tim Kelley (CalTech).
   *
   * \param array_in (INPUT) is the array to be multipled
   * \param array_in_err2 (INPUT) is the square of the uncertainty in the
   * array to be multiplied
   * \param scalar (INPUT) is the scalar to multiply to each element
   * of array_in
   * \param scalar_err2 (INPUT) is the square of the uncertainty in the
   * scalar
   * \param array_out (OUTPUT) is the result array
   * \param array_out_err2 (OUTPUT) is the square of the uncertainty in
   * the result array
   *
   * \param temp holds temporary memory to be passed to the function
   *
   * \return A set of warnings generated by the function
   *
   * <b>Warning when using integers</b>
   * One must be aware of the overflow property when using integers.
   * The overflow occurs when trying to use negative numbers with unsigned
   * int and number outside the range with ints (signed and unsigned).
   *
   * As an  example, \f$2-4\f$ will return \f$UINT\_MAX-1\f$, where
   * \f$UINT\_MAX\f$ is the largest value that will fit in an unsigned int.
   * Because the true result of the equation is negative, which
   * is not allowed with unsigned int, the result is wrapped around 0.
   * To generalize, the result returned with unsigned int is
   * \f[
   * result_{returned} = (result_{real})\ \%\ (UINT\_MAX + 1)
   * \f]
   * where \f$result_{returned}\f$ is the result returned by the function,
   * \f$result_{real}\f$ is the real result that should be returned by the
   * function, and \f$\%\f$ is the operator modulo.
   *
   * \exception std::invalid_argument is thrown if the size of
   * array_in, array_in_err2, array_out, and array_out_err2 are not
   * identical.
   */
  template <typename NumT>
  std::string
  mult_ncerr(const Nessi::Vector<NumT> & array_in,
             const Nessi::Vector<NumT> & array_in_err2,
             const NumT scalar,
             const NumT scalar_err2,
             Nessi::Vector<NumT> & array_out,
             Nessi::Vector<NumT> & array_out_err2,
             void *temp=NULL);

  /**
   * \}
   */ // end of mult_ncerr group
 
  /**
   * \defgroup sub_ncerr ArrayManip::sub_ncerr
   * \{
   */

  /**
   * \brief This function is described in section 3.7.
   *
   * This function subtracts each element, \f$i\f$, two arrays
   * according to the equation
   * \f[
   * data_o[i]=data_1[i]-data_2[i]
   * \f]
   * and the uncorrelated uncertainties will be processed according to
   * the equation
   * \f[
   * \sigma_o^2[i]=\sigma_1^2[i]+\sigma_2^2[i]
   * \f]
   * Where \f$data_o[i]\f$ is the \f$i^{th}\f$ component of the output
   * array, \f$data_1[i]\f$ is the \f$i^{th}\f$ component being subtracted from
   * each element, \f$data_2[i]\f$ is the \f$i^{th}\f$ component of
   * the array subtracting, \f$\sigma_o[i]\f$ is the \f$i^{th}\f$
   * component of the uncertainty of the output array,
   * \f$\sigma_1[i]\f$ is the \f$i^{th}\f$ component of the
   * uncertainty in the array begin subtracted from and
   * \f$\sigma_2[i]\f$ is the \f$i^{th}\f$ component of the
   * uncertainty in the array subtracting.
   *
   * This function is an adaptation from the ARCS reduction software written
   * by Tim Kelley (CalTech).
   *
   * \param input1 (INPUT) is the array to be subtracted from
   * \param input1_err2 (INPUT) is the square of the uncertainty in
   * the array to be subtracted from
   * \param input2 (INPUT) is the array to subtract
   * \param input2_err2 (INPUT) the square of the uncertainty in the
   * array to subtract
   * \param output (OUTPUT) the result array
   * \param output_err2 (OUTPUT) the square of the uncertainty in the
   * result array
   *
   * \param temp holds temporary memory to be passed to the function
   *
   * \return A set of warnings generated by the function
   *
   * <b>Warning when using integers</b>
   * One must be aware of the overflow property when using integers.
   * The overflow occurs when trying to use negative numbers with unsigned
   * int and number outside the range with ints (signed and unsigned).
   *
   * As an  example, \f$2-4\f$ will return \f$UINT\_MAX-1\f$, where
   * \f$UINT\_MAX\f$ is the largest value that will fit in an unsigned int.
   * Because the true result of the equation is negative, which
   * is not allowed with unsigned int, the result is wrapped around 0.
   * To generalize, the result returned with unsigned int is
   * \f[
   * result_{returned} = (result_{real})\ \%\ (UINT\_MAX + 1)
   * \f]
   * where \f$result_{returned}\f$ is the result returned by the function,
   * \f$result_{real}\f$ is the real result that should be returned by the
   * function, and \f$\%\f$ is the operator modulo.
   *
   * \exception std::invalid_argument is thrown if the size of input1,
   * input1_err2, input2, input2_err2, output, and output_err2 are not
   * identical.
   */
  template <typename NumT>
  std::string
  sub_ncerr(const Nessi::Vector<NumT> & input1,
            const Nessi::Vector<NumT> & input1_err2,
            const Nessi::Vector<NumT> & input2,
            const Nessi::Vector<NumT> & input2_err2,
            Nessi::Vector<NumT> & output,
            Nessi::Vector<NumT> & output_err2,
            void *temp=NULL);

  /**
   * \brief This function is described in section 3.2.
   *
   * This function subtracts a scalar from each element, \f$i\f$, of
   * an array according to the equation
   * \f[
   * data_o[i]=data_i[i]-a
   * \f]
   * and the uncorrelated uncertainties will be processed according to
   * the equation
   * \f[
   * \sigma_o^2[i]=\sigma_i^2[i]+\sigma_a^2
   * \f]
   * Where \f$data_o[i]\f$ is the \f$i^{th}\f$ component of the output
   * array, \f$a\f$ is the scalar being subtracted from each element,
   * \f$data_i[i]\f$ is the \f$i^{th}\f$ component of the input array,
   * \f$\sigma_o[i]\f$ is the \f$i^{th}\f$ component of the
   * uncertainty of the output array, \f$\sigma_a\f$ is the
   * uncertainty in the scalar, and \f$\sigma_i[i]\f$ is the
   * \f$i^{th}\f$ component of the uncertainty in the input array.
   *
   * This function is an adaptation from the ARCS reduction software written
   * by Tim Kelley (CalTech).
   *
   * \param array_in (INPUT) is the array to be subtracted from
   * \param array_in_err2 (INPUT) is the square of the uncertainty in the
   * array to be subtracted from
   * \param scalar (INPUT) is the scalar to subtract from each element of
   * array_in
   * \param scalar_err2 (INPUT) is the square of the uncertainty in the
   * scalar
   * \param array_out (OUTPUT) is the result array
   * \param array_out_err2 (OUTPUT) is the square of the uncertainty in
   * the result array
   *
   * \param temp holds temporary memory to be passed to the function
   *
   * \return A set of warnings generated by the function
   *
   * <b>Warning when using integers</b>
   * One must be aware of the overflow property when using integers.
   * The overflow occurs when trying to use negative numbers with unsigned
   * int and number outside the range with ints (signed and unsigned).
   *
   * As an  example, \f$2-4\f$ will return \f$UINT\_MAX-1\f$, where
   * \f$UINT\_MAX\f$ is the largest value that will fit in an unsigned int.
   * Because the true result of the equation is negative, which
   * is not allowed with unsigned int, the result is wrapped around 0.
   * To generalize, the result returned with unsigned int is
   * \f[
   * result_{returned} = (result_{real})\ \%\ (UINT\_MAX + 1)
   * \f]
   * where \f$result_{returned}\f$ is the result returned by the function,
   * \f$result_{real}\f$ is the real result that should be returned by the
   * function, and \f$\%\f$ is the operator modulo.
   *
   * \exception std::invalid_argument is thrown if the size of
   * array_in, array_in_err2, array_out, and array_out_err2 are not
   * identical.
   */
  template <typename NumT>
  std::string
  sub_ncerr(const Nessi::Vector<NumT> & array_in,
            const Nessi::Vector<NumT> & array_in_err2,
            const NumT scalar,
            const NumT scalar_err2,
            Nessi::Vector<NumT> & array_out,
            Nessi::Vector<NumT> & array_out_err2,
            void *temp=NULL);

 /**
   * \brief This function is described in section 3.44.
   *
   * This function subtracts each element from a scalar, \f$i\f$, of
   * an array according to the equation
   * \f[
   * data_o[i]=a-data_i[i]
   * \f]
   * and the uncorrelated uncertainties will be processed according to
   * the equation
   * \f[
   * \sigma_o^2[i]=\sigma_i^2[i]+\sigma_a^2
   * \f]
   * Where \f$data_o[i]\f$ is the \f$i^{th}\f$ component of the output
   * array, \f$data_i[i]\f$ is the \f$i^{th}\f$ component of the input array
   * being subtracted from the scalar, \f$a\f$ is the scalar
   * \f$\sigma_o[i]\f$ is the \f$i^{th}\f$ component of the
   * uncertainty of the output array, \f$\sigma_a\f$ is the
   * uncertainty in the scalar, and \f$\sigma_i[i]\f$ is the
   * \f$i^{th}\f$ component of the uncertainty in the input array.
   *
   * This function is an adaptation from the ARCS reduction software written
   * by Tim Kelley (CalTech).
   *
   * \param scalar (INPUT) is the scalar to subtract from each element of
   * array_in
   * \param scalar_err2 (INPUT) is the square of the uncertainty in the
   * scalar
   * \param array_in (INPUT) is the array to be subtracted from
   * \param array_in_err2 (INPUT) is the square of the uncertainty in the
   * array to be subtracted from
   * \param array_out (OUTPUT) is the result array
   * \param array_out_err2 (OUTPUT) is the square of the uncertainty in
   * the result array
   *
   * \param temp holds temporary memory to be passed to the function
   *
   * \return A set of warnings generated by the function
   *
   * <b>Warning when using integers</b>
   * One must be aware of the overflow property when using integers.
   * The overflow occurs when trying to use negative numbers with unsigned
   * int and number outside the range with ints (signed and unsigned).
   *
   * As an  example, \f$2-4\f$ will return \f$UINT\_MAX-1\f$, where
   * \f$UINT\_MAX\f$ is the largest value that will fit in an unsigned int.
   * Because the true result of the equation is negative, which
   * is not allowed with unsigned int, the result is wrapped around 0.
   * To generalize, the result returned with unsigned int is
   * \f[
   * result_{returned} = (result_{real})\ \%\ (UINT\_MAX + 1)
   * \f]
   * where \f$result_{returned}\f$ is the result returned by the function,
   * \f$result_{real}\f$ is the real result that should be returned by the
   * function, and \f$\%\f$ is the operator modulo.
   *
   * \exception std::invalid_argument is thrown if the size of
   * array_in, array_in_err2, array_out, and array_out_err2 are not
   * identical.
   */
  template <typename NumT>
  std::string
  sub_ncerr(const NumT scalar,
            const NumT scalar_err2,
            const Nessi::Vector<NumT> & array_in,
            const Nessi::Vector<NumT> & array_in_err2,
            Nessi::Vector<NumT> & array_out,
            Nessi::Vector<NumT> & array_out_err2,
            void *temp=NULL);

  /**
   * \}
   */ // end of sub_ncerr group


  /**
   * \defgroup sumw_ncerr ArrayManip::sumw_ncerr
   * \{
   */

  /**
   * \brief This function is described in section 3.10.
   *
   * This function adds two arrays weighted by their uncertainties
   * according to the equation
   * \f[
   * data_o[i]=\left( \sum^N_{n=1} \frac{data_n[i]}{\sigma_n[i]}\right)
   * \times\left( \frac{1}{N} \sum^N_{n=1} \sigma_n[i] \right)
   * \f]
   * where \f$N=2\f$ and the uncorrelated uncertainties will be processed
   * according to the equation
   * \f[
   * \sigma_o^2[i]=\left( \sigma_1^2\sigma_2 + \sigma_1\sigma_2^2 \right)
                   \left( \sigma_1 + \sigma_2 \right)
   * \f]
   * However, if the uncertainty in any of the data is not specified,
   * or is zero, the value of the \f$data_o[i]\f$ will be given by
   * \f[
   * data_o[i]=\sum^N_{n=1} data_n[i]
   * \f]
   * Where \f$data_o[i]\f$ is the \f$i^{th}\f$ component of the output
   * array, \f$data_n[i]\f$ is the \f$i^{th}\f$ component of the
   * \f$n^{th}\f$ array being added, \f$\sigma_o[i]\f$ is the
   * \f$i^{th}\f$ component of the uncertainty of the output array,
   * and \f$\sigma_n[i]\f$ is the \f$i^{th}\f$ component of the
   * uncertainty in the \f$n^{th}\f$ array being added.
   *
   * \param input1 (INPUT) is the first array to be added
   * \param input1_err2 (INPUT) is the square of the uncertainty in
   * the first array to be added
   * \param input2 (INPUT) is the second array to be added
   * \param input2_err2 (INPUT) the square of the uncertainty in the
   * second array to be added
   * \param output (OUTPUT) the result array
   * \param output_err2 (OUTPUT) the square of the uncertainty in the
   * result array
   *
   * \param temp holds temporary memory to be passed to the function
   *
   * \return A set of warnings generated by the function
   *
   * <b>Warning when using integers</b>
   * One must be aware of the overflow property when using integers.
   * The overflow occurs when trying to use negative numbers with unsigned
   * int and number outside the range with ints (signed and unsigned).
   *
   * As an  example, \f$2-4\f$ will return \f$UINT\_MAX-1\f$, where
   * \f$UINT\_MAX\f$ is the largest value that will fit in an unsigned int.
   * Because the true result of the equation is negative, which
   * is not allowed with unsigned int, the result is wrapped around 0.
   * To generalize, the result returned with unsigned int is
   * \f[
   * result_{returned} = (result_{real})\ \%\ (UINT\_MAX + 1)
   * \f]
   * where \f$result_{returned}\f$ is the result returned by the function,
   * \f$result_{real}\f$ is the real result that should be returned by the
   * function, and \f$\%\f$ is the operator modulo.
   *
   * \exception std::invalid_argument is thrown if the size of input1,
   * input1_err2, input2, input2_err2, output, and output_err2 are not
   * identical.
   */
  template <typename NumT>
  std::string
  sumw_ncerr(const Nessi::Vector<NumT> & input1,
             const Nessi::Vector<NumT> & input1_err2,
             const Nessi::Vector<NumT> & input2,
             const Nessi::Vector<NumT> & input2_err2,
             Nessi::Vector<NumT> & output,
             Nessi::Vector<NumT> & output_err2,
             void *temp=NULL);

  /**
   * \}
   */ // end of sumw_ncerr group

} // ArrayManip

#endif // _ARITH_HPP
